#### 生成器
- 概念

    ```
    在Python中， 一边循环一边计算的机制， 称为生成器： generator 
    创建生成器: G = ( x*2 for x in range(5)) 
    可以通过 next(生成器) 函数获得生成器的下一个返回值
     没有更多的元素时， 抛出 StopIteration 的异常 
    生成器也可以使for 循环，因为生成器也是可迭代对象
    ```

- 生成器 生成的第一种方式

    ```
    list2 = [x for x in range(10)]
    print(type(list2))
    # 得到一个生成器对象
    g = (x*2 for x in range(10))
    print(type(g))
    # 打印生成器生成的第一个数字
    print(next(g))
    print(next(g))
    print(next(g))
    一共10个数字，打印超出报StopIteration异常
    ```

- 生成器应用
    - 使用循环求斐波那契的第n个数

    ```
    def feibo(items):
        a, b, n  = 1, 1, 3
        while n <= items:
            if items == 1 or items == 2:
                return 1
            else:
                a, b = b, a + b
                print(b, end=" ")
                n += 1
        return b
    print(feibo(4))
    ```

    - 生成器的第二种生成方式  yield

    ```
    def feibo(items):
        a, b, n = 1, 1, 3
        while n <= items:
            if items == 1 or items == 2:
                return 1
            else:
                a, b = b, a + b
                # 关键字yield让该函数变成生成器
                yield b
                n += 1
        return b
    # 得到的是生成器对象
    g = feibo(5)
    print(type(g))
    print(next(g))
    # 使用生成器调用__next__()方法,等价于next(g)
    print(g.__next__())
    print("--------for循环遍历结果---------")
    # 可以使用for循环遍历生成器
    for a in g:
        print(a)
    ```
    - 生成器之send()用法

    ```
    def test():
        i = 0
        while i < 5:
    #赋值运算下次会被执行  yield会使程序停住
            temp = yield i
            print(temp)
            i += 1
    g = test()
    print("-----send----")
    print(g.__next__())
    print(next(g))
    print(g.send("aaa"))
    运行结果：
    -----send----
    0
    None
    1
    aaa
    2
    ```

    - 首次调用send()异常问题

    ```
    def test():
        i = 0
        while i < 5:
            temp = yield i
            print(temp)
            i += 1
    g = test()
    print("-----send----")
    # 首次调用不传参或者传递非None参数都会导致异常
    print(g.send())
    print(g.send("aaa"))
    解决方案：
    1.首次调用使用__next__()，不使用send()
    2.或者首次使用send(None)
    ```

    - yield完成多任务

    ```
    需求： 先存钱，再取钱，两个任务交替进行
    def test1():
        while True:
            print("存钱")
            yield None
    def test2():
        while True:
            print("取钱")
            yield None
    t1 = test1()
    t2 = test2()
    while True:
        t1.__next__()
        t2.__next__()
    ```


- 好处

    ```
    需要新的数字，就生成一个新的，不同于列表，需要一下子全出来，
    更占用内存
    ```

#### 迭代器

```
迭代是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象 。
迭代器只能往前不会后退
```

- 可迭代对象（Iterable）
    
    ```
    集合数据类型， 如 list 、 tuple 、 dict 、 set 、 str 等 
    成器和带 yield 的generator function
    这些可以直接作用于for循环的对象成为可迭代对象：Iterable
    ```

- 如何判断对象是可迭代对象（Iterable）
    
    ```
    可以使用isinstable()判断一个对象是否为可迭代对象
    导包:
    from collections import Iterable
    list1 = [x for x in range(5)]
    print(isinstance(list1,Iterable))
    案例：
    分别验证，列表，字典，元组，字符串，生成器是否为可迭代对象
    ```

- 迭代器（Iterator）
    
    ```
    可以被next()函数调⽤并不断返回下⼀个值的对象称为迭代器
    可以使用isinstance(对象,Iterator)判断对象是否为迭代器
    from collections import Iterator 
    isinstance((x for x in range(10)), Iterator) 
    案例验证： 列表，字典，字符串，元组,生成器是否为迭代器对象
    ```

- iter()函数

    ```
    分别验证将列表，字典，元组，字符串转换为迭代器，使用next()进行访问
    ```
#### 闭包1
- 什么是闭包？

    ```
    内部函数对外部函数作用域内变量的引用（非全局变量） ， 则称内部函数为闭包
    三个条件，缺一不可：
    1)必须有一个内嵌函数(函数里定义的函数）——这对应函数之间的嵌套
    2)内嵌函数必须引用一个定义在闭合范围内(外部函数里)的变量——内部函数引用外部变量
    3)外部函数必须返回内嵌函数——必须返回那个内部函数
    ```

- 案例：完成一个闭包的定义以及基本使用（nonlocal）

```
    # 定义一个外部函数
    def funcationout(num1):
        print("out start")
        # 函数内定义另外一个函数
        def funcationin(num2):
            # 并且在函数中用到了外部的变量(非全局变量)num2
            result = num1 + num2
            print("in----")
            print(result)
            return result
        print("out end")
        # 外部函数的返回值为内部函数名（内部函数的引用）
        return funcationin
    # 调用外部函数,得到一个指向内部函数的变量（闭包）
    infunc = funcationout(100)
    # 外部函数中的变量，没有随着函数的结束而释放，
    # 而是在闭包中可以随时进行调用
    infunc(200)
    infunc(1)
```
- 以上代码执行内存分析
    - 画图分析
#### 闭包2
- 闭包的作用

    ```
    闭包主要是在函数式开发过程中使用
    可以根据外部作用域的局部变量来得到不同的结果
    ```

- 闭包作用案例验证

    ```
    比如：求一个点到其他点之间的距离（不使用闭包，使用闭包分别验证）
    from math import *
    # 不使用闭包需要4个参数
    def disbtwpoint(x1,y1,x2,y2):
        return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))
    # 不使用闭包的调用求距离函数
    print(disbtwpoint(0,0,10,10))
    print(disbtwpoint(0,0,20,10))
    
    def disout(x1,y1):
        def disin(x2,y2):
            return sqrt(pow(x1-x2,2)+pow(y1-y2,2))
        return disin
    # 闭包getdis
    getdis = disout(0,0)
    # 获取点10,10到坐标（0,0）的距离
    print(getdis(10,10))
    # 获取点20,10到坐标（0,0）的距离
    print(getdis(20,10))
    ```


#### 装饰器1
- 装饰器简介

    ```
    装饰器本质上是一个Python函数，它可以让其他函数在
    不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个
    函数对象。它经常用于有以下场景，比如：插入日志、性能测试、
    事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，
    概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能
    ```
- 装饰器的解决日志问题（分三个版本）
    - v1.0版本解决

        ```
        def fun1():
            print("日志记录")
            print("使用功能1")
        
        def fun2():
            print("日志记录")
            print("使用功能2")
        ```
    - v2.0版本解决

        ```
        def writeLog():
            pass
        def fun1():
            writeLog()
            print("使用功能1")
        def fun2():
            writeLog()
            print("使用功能2")
        ```

    - v3.0版本解决

        ```
        def outfunc(func):
            def infunc():
                writeLog()
                func()
            return infunc
        def fun1():
            print("使用功能1")
        def fun2():
            print("使用功能2")
       
        # 注意名字的问题，需要分析
        fun1 = outfunc(fun1)
        # 装饰器(闭包)
        fun1()
        ```

    - v4.0版本解决 简化装饰器
        ```
        def outfunc(func):
            def infunc():
                writeLog()
                func()
            return infunc
        @outfunc
        def fun1():
            print("使用功能1")
        @outfunc
        def fun2():
            print("使用功能2")
        
        fun1()
        fun2()
        ```

#### 装饰器2
- 多个装饰器问题

    ```
    def add1(fc):
    print("add1正在装饰")
        def wrapped():
            return "《"+fc()+"》"
        return wrapped
    def add2(fc):
    print("add2正在装饰")
        def wrapped():
            return '*'+fc()+'*'
        return wrapped
    #看到这个，开始进行装饰，而不是等到调用时
    @add1
    @add2
    def test1():
        return '金陵十三钗'
    print(test1())
    打印结果：
    add2开始装饰
    add1开始装饰
    《*金陵十三钗*》
    ```
- 对有参数的函数进行装饰
    - 固定个数的参数
        ```
        def func(fn):
            print("func")
            def func_in(aa, bb):
                print("func_in1")
                fn(aa,bb)
                print("func_in2")
            return func_in
        @func
        def test(a, b):
            print("a=%d,b=%d" % (a, b))
        # 装饰器装饰之后，这不是直接调用test方法，而是调用func_in方法
        test(1,2)
        ```

    - 不固定个数的参数
        ```
        def func(fn):
            print("func")
            def func_in(*args,**kwargs):
                print("func_in1")
                # 注意参数类型，原封不动的继续使用
                fn(*args,**kwargs)
                print("func_in2")
            return func_in
        @func
        def test1(a,b,c,d):
            print("a=%d b=%d c=%d d= %d"%(a,b,c,d))
        test1(1,2, 3, 4)
        ```

#### 装饰器3
- 通用装饰器
    ```
    def func(fn):
        # 需要有参数，*args,**kwargs
        def func_in(*args,**kwargs):
            print("记录日志")
            print('访问方法:'+fn.__name__)
            # 需要有参数，*args,**kwargs
            xx = fn(*args,**kwargs)
            # 需要有返回值
            return xx
        return func_in
    
    # 待装饰函数：无参数，无返回值
    @func
    def test1():
        print("test1")
    test1()
    @func
    def test2():
        return "Hello"
    print(test2())
    @func
    def test3(a):
        print('a=%d'%a)
    test3(1)
    ```

#### python动态添加属性方法
```
动态编程语言是 高级程序设计语言 的一个类别， 在计算机科学领域已被广泛应用。
 它是指类 在 运行时可以改变其结构 的语言 ： 例如新的函数、 对象、甚至代码可以被引进，
 已有的函数可以被删除或是其他结构上的变化。
```
- 运行过程中给对象、类添加属性、添加方法

    ```
    class Person():
        def __init__(self,name,age):
            self.name = name
            self.age = age
    # 给类添加属性
    Person.score = 1000
    p1 = Person('xxx',20)
    print(p1.score)
    #单独定义一个函数 run 
    def run(self):
        print("%s在跑"%self.name)
    # 使用这种方式进行绑定
    p1.run = run
    # 在这调用直接报错
    # p1.run
    import types
    # 将run方法与对象进行绑定
    p1.run = types.MethodType(run,p1)
    # 完成调用，解决问题
    p1.run()
    ```

- types.MethonType的使用

    ```
    p1.run = types.MethodType(run,p1)
    即使换成
    xxx = types.MethodType(run,p1)
    xxx()调用一样还用
    因为之前提示缺少参数，主要是不知道self到底是谁，
    而types.MethodType(run,p1)则是告诉解释器，self指的就是p1
    ```

- 添加静态方法以及类方法

```
@staticmethod
def staticfunc():
    print("---static method---")
Person.staticfunc = staticfunc
Person.staticfunc()
@classmethod
def clsfunc(cls):
    print('---cls method---')
Person.clsfunc = clsfunc
Person.clsfunc()
```

#### __slots__的作用

```
class Person():
    # 限定Person类中，只能拥有name，跟age，如果添加新的属性，会报错
    # 注意，只能限定当前类，对子类不好使
    __slots__ = ('name','age')
代码验证
```


